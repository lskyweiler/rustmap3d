# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins

def aer2ecef(
    aer: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER to ECEF.

    # Arguments

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    * `ref_lla` - Reference latitude-longitude-altitude [radians-radians-meters].

    # Returns

    * `ecef` - Vector represented in ECEF coordinates [meters].
    """

def aer2enu(
    aer: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER to ENU.

    # Arguments

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def aer2ned(
    aer: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER to NED.

    # Arguments

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def angle_between(
    a: tuple[builtins.float, builtins.float, builtins.float],
    b: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def ecef2aer(
    ecef: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF to AER.

    # Arguments

    * `ecef` - Vector represented in ECEF coordinates [meters].
    * `ref_lla` - Reference latitude-longitude-altitude [radians-radians-meters].

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def ecef2bearing(
    obs_ecef: tuple[builtins.float, builtins.float, builtins.float],
    targ_ecef: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def ecef2enu(
    ecef: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF to ENU.

    # Arguments

    * `ecef` - Vector represented in ECEF coordinates [meters].
    * `lla_ref` - Reference latitude-longitude-altitude [degrees-degrees-meters].

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def ecef2enu_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ECEF to ENU transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `dcm` - ECEF to ENU direction cosine matrix.
    """

def ecef2enu_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ECEF to ENU transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `quat` - Normalized ECEF to ENU quaternion.
    """

def ecef2heading(
    ecef_rel: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def ecef2lla(
    ecef: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF to LLA.

    # Arguments

    * `ecef` - Vector represented in ECEF coordinates [meters].

    # Returns

    * `lla` - Vector represented in LLA coordinates [degrees-degrees-meters].
    """

def ecef2ned(
    ecef: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF to NED.

    # Arguments

    * `ecef` - Vector represented in ECEF coordinates [meters].
    * `lla_ref` - Reference latitude-longitude-altitude [degrees-degrees-meters].

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def ecef2ned_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ECEF to NED transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `dcm` - ECEF to NED direction cosine matrix.
    """

def ecef2ned_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ECEF to NED transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `quat` - Normalized ECEF to NED quaternion.
    """

def ecef_quat2heading(
    ecef_quat: tuple[builtins.float, builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def enu2aer(
    enu: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to AER.

    # Arguments

    * `enu` - Vector represented in ENU coordinates [meters].

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def enu2ecef(
    enu: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to ECEF.

    # Arguments

    * `enu` - Vector represented in ENU coordinates [meters].
    * `lla_ref` - Reference latitude-longitude-altitude [degrees-degrees-meters].

    # Returns

    * `ecef` - Vector represented in ECEF coordinates [meters].
    """

def enu2ecef_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ENU to ECEF transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `dcm` - ENU to ECEF direction cosine matrix.
    """

def enu2ecef_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ENU to ECEF transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `quat` - Normalized ENU to ECEF quaternion.
    """

def enu2heading(
    enu: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float:
    r"""
    Calculates heading angle from ENU.

    # Arguments

    * `enu` - Vector represented in ENU coordinates [meters].

    # Returns

    * `heading_deg` - Heading angle relative to true north [degrees].
    """

def lla2ecef(
    lla: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts LLA to ECEF.

    # Arguments

    * `lla` - Vector represented in LLA coordinates [degrees-degrees-meters].

    # Returns

    * `ecef` - Vector represented in ECEF coordinates [meters].
    """

def ned2aer(
    ned: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts NED to AER.

    # Arguments

    * `ned` - Vector represented in NED coordinates [meters].

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def ned2ecef(
    ned: tuple[builtins.float, builtins.float, builtins.float],
    lla_ref: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts NED to ECEF.

    # Arguments

    * `ned` - Vector represented in NED coordinates [meters].
    * `lla_ref` - Reference latitude-longitude-altitude [degrees-degrees-meters].

    # Returns

    * `ecef` - Vector represented in ECEF coordinates [meters].
    """

def ned2ecef_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an NED to ECEF transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `dcm` - NED to ECEF direction cosine matrix.
    """

def ned2ecef_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an NED to ECEF transformation at this LLA.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].

    # Returns

    * `quat` - Normalized NED to ECEF quaternion.
    """

def rand_ecef() -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Generates a uniform random ECEF point on the surface of a spherical Earth.

    # Returns

    * `ecef` - Random ECEF location [meters].
    """

def rand_lla() -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Generates a uniform random LLA point. Altitude is generated in the domain [0.0, 10000.0].

    # Returns

    * `lla` - Random LLA location [degrees-degrees-meters].
    """

def rand_orientation() -> tuple[
    builtins.float, builtins.float, builtins.float, builtins.float
]:
    r"""
    Generates a random normalized quaternion.

    # Returns

    * `quat` - Random normalized quaternion.
    """

def vincenty_direct(
    lat_deg: builtins.float,
    lon_deg: builtins.float,
    range_m: builtins.float,
    bearing_deg: builtins.float,
    atol: builtins.float,
    max_iters: builtins.int,
) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculates the LLA location that is a fixed range and bearing from a reference LLA. This function uses an iterative
    solution to determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_deg` - Latitude reference [degrees].
    * `lon_deg` - Longitude reference [degrees].
    * `range_m` - Range (i.e., distance) from point A to point B [meters].
    * `bearing_deg` - Bearing (i.e., azimuth) from point A to point B relative to true north [degrees].
    * `abs_tol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(lat_deg, lon_deg)` where:
    * `lat_deg` - Latitude location [degrees].
    * `lon_deg` - Longitude location [degrees].
    """

def vincenty_inverse(
    lat_a_deg: builtins.float,
    lon_a_deg: builtins.float,
    lat_b_deg: builtins.float,
    lon_b_deg: builtins.float,
    atol: builtins.float,
    max_iters: builtins.int,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates range and bearings between two latitude-longitude points. This function uses an iterative solution to
    determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_a_deg` - Latitude point A [degrees].
    * `lon_a_deg` - Longitude point A [degrees].
    * `lat_b_deg` - Latitude point A [degrees].
    * `lon_b_deg` - Longitude point A [degrees].
    * `atol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(range_m, bearing_ab_deg, bearing_ba_deg)` where:
    * `range_m` - Range (i.e., distance) from point A to point B [meters].
    * `bearing_ab_deg` - Bearing (i.e., azimuth) from point A to point B relative to true north [degrees].
    * `bearing_ba_deg` - Bearing (i.e., azimuth) from point B to point A relative to true north [degrees].
    """
