# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins

def aer2ecef(
    a: builtins.float,
    e: builtins.float,
    r: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
    alt: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def aer2enu(
    a: builtins.float, e: builtins.float, r: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def aer2ned(
    a: builtins.float, e: builtins.float, r: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def angle_between(
    a: tuple[builtins.float, builtins.float, builtins.float],
    b: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def ecef2aer(
    x: builtins.float,
    y: builtins.float,
    z: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ecef2bearing(
    obs_ecef: tuple[builtins.float, builtins.float, builtins.float],
    targ_ecef: tuple[builtins.float, builtins.float, builtins.float],
) -> builtins.float: ...
def ecef2enu(
    x: builtins.float,
    y: builtins.float,
    z: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ecef2enu_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]: ...
def ecef2enu_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]: ...
def ecef2heading(
    ecef_rel: tuple[builtins.float, builtins.float, builtins.float],
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> builtins.float: ...
def ecef2lla(
    x: builtins.float, y: builtins.float, z: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ecef2ned(
    x: builtins.float,
    y: builtins.float,
    z: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ecef2ned_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]: ...
def ecef2ned_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]: ...
def ecef_quat2heading(
    ecef_quat: tuple[builtins.float, builtins.float, builtins.float, builtins.float],
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> builtins.float: ...
def enu2aer(
    e: builtins.float, n: builtins.float, u: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def enu2ecef(
    e: builtins.float,
    n: builtins.float,
    u: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def enu2ecef_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]: ...
def enu2ecef_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]: ...
def enu2heading(
    east: builtins.float, north: builtins.float, up: builtins.float
) -> builtins.float: ...
def lla2ecef(
    lat: builtins.float, lon: builtins.float, alt: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ned2aer(
    n: builtins.float, e: builtins.float, d: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ned2ecef(
    n: builtins.float,
    e: builtins.float,
    d: builtins.float,
    ref_lat: builtins.float,
    ref_lon: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]: ...
def ned2ecef_dcm(
    lat: builtins.float, lon: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]: ...
def ned2ecef_quat(
    lat: builtins.float, lon: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]: ...
def orient_ecef_quat_towards_lla(
    obs_ecef: tuple[builtins.float, builtins.float, builtins.float],
    obs_ecef_quat: tuple[
        builtins.float, builtins.float, builtins.float, builtins.float
    ],
    target_ecef: tuple[builtins.float, builtins.float, builtins.float],
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]: ...
def rand_ecef() -> tuple[builtins.float, builtins.float, builtins.float]: ...
def rand_lla() -> tuple[builtins.float, builtins.float, builtins.float]: ...
def rand_orientation() -> tuple[
    builtins.float, builtins.float, builtins.float, builtins.float
]: ...
def vincenty_direct(
    lat_deg: builtins.float,
    lon_deg: builtins.float,
    range_m: builtins.float,
    bearing_deg: builtins.float,
    atol: builtins.float,
    max_iters: builtins.int,
) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculates the LLA location that is a fixed range and bearing from a reference LLA. This function uses an iterative
    solution to determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_deg` - Latitude reference [[degrees]].
    * `lon_deg` - Longitude reference [[degrees]].
    * `range_m` - Range (i.e., distance) from point A to point B [[meters]].
    * `bearing_deg` - Bearing (i.e., azimuth) from point A to point B relative to true north [[degrees]].
    * `abs_tol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(lat_deg, lon_deg)` where:
    * `lat_deg` - Latitude location [[degrees]].
    * `lon_deg` - Longitude location [[degrees]].
    """

def vincenty_inverse(
    lat_a_deg: builtins.float,
    lon_a_deg: builtins.float,
    lat_b_deg: builtins.float,
    lon_b_deg: builtins.float,
    atol: builtins.float,
    max_iters: builtins.int,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates range and bearings between two latitude-longitude points. This function uses an iterative solution to
    determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_a_deg` - Latitude point A [[degrees]].
    * `lon_a_deg` - Longitude point A [[degrees]].
    * `lat_b_deg` - Latitude point A [[degrees]].
    * `lon_b_deg` - Longitude point A [[degrees]].
    * `atol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(range_m, bearing_ab_deg, bearing_ba_deg)` where:
    * `range_m` - Range (i.e., distance) from point A to point B [[meters]].
    * `bearing_ab_deg` - Bearing (i.e., azimuth) from point A to point B relative to true north [[degrees]].
    * `bearing_ba_deg` - Bearing (i.e., azimuth) from point B to point A relative to true north [[degrees]].
    """
