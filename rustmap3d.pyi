# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import builtins
import typing

@typing.final
class DQuat:
    r"""
    4 Component Quaternion wxyz
    """
    def __new__(
        cls, x: builtins.float, y: builtins.float, z: builtins.float, w: builtins.float
    ) -> DQuat:
        r"""
        Create a new quaternion from components.
        Usually you want `from_axis_angle` or `from_rotation_arc` instead of this

        # Arguments

        - `x` (`float`) - x component
        - `y` (`float`) - y component
        - `z` (`float`) - z component
        - `w` (`float`) - scalar component

        # Returns

        - `PyResult<Self>` - Describe the return value.
        """
    @staticmethod
    def from_axis_angle(axis: DVec3, angle: builtins.float) -> DQuat:
        r"""
        Create a new quaternion from an axis and angle

        # Arguments

        - `axis` (`vec3`) - Axis, should be normalized
        - `angle` (`float`) - Angle in radians

        # Returns

        - `PyResult<Self>` - Quaternion describing this axis/angle rotation
        """
    @staticmethod
    def from_rotation_arc(from_: DVec3, to: DVec3) -> DQuat:
        r"""
        Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
        plane spanned by the two vectors.  Will rotate at most 180 degrees.

        `from_rotation_arc(from, to) * from ≈ to`.

        For near-singular cases (from≈to and from≈-to) the current implementation
        is only accurate to about 0.001 (for `f32`).

        # Arguments

        - `from_` (`vec3`) - starting vector. Must be a unit vector
        - `to` (`vec3`) - ending vector. Must be a unit vector

        # Returns

        - `PyResult<Self>` - Returns a quaternion that would rotate vector from onto to
        """
    def to_tuple(
        self,
    ) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
        r"""
        Convert this quat to a 4 component tuple

        # Returns

        - `(float, float, float, float)` - XYZW tuple
        """
    def __mul__(self, rhs: typing.Any) -> typing.Union[DQuat, DVec3]:
        r"""
        Multiply this quaternion with either another quaternion or a vector

        A quaternion multiplication means combining two rotations into a single rotation
        A vector multiplication yields a rotated vec3

        # Arguments

        - `rhs` (`Bound<'_, PyAny>`) - Quat or Vec to multiply

        # Returns

        - `PyResult<Either<, >>` - Either a new rotation or a rotated vector
        """
    def __rmul__(self, lhs: typing.Any) -> typing.Union[DQuat, DVec3]:
        r"""
        Multiply this quaternion with either another quaternion or a vec3

        Order doesn't matter for multiplying a vector and a quat, but order matters for multiplying two quats

        # Arguments

        - `lhs` (`Bound<'_, PyAny>`) - left hand side multiplicand

        # Returns

        - `PyResult<Either<, >>` - Either a quat equivalent to the combined rotation or a rotated vector
        """
    def normalize(self) -> DQuat:
        r"""
        Normalize this quaternion into a unit quat
        """
    def conjugate(self) -> DQuat:
        r"""
        Compute the conjugate of this quat.
        If this is a unit quat, the conjugate is equal to the inverse of the rotation
        """

@typing.final
class DVec3:
    r"""
    3 Component vector xyz
    """
    @property
    def x(self) -> builtins.float: ...
    @x.setter
    def x(self, value: builtins.float) -> None: ...
    @property
    def y(self) -> builtins.float: ...
    @y.setter
    def y(self, value: builtins.float) -> None: ...
    @property
    def z(self) -> builtins.float: ...
    @z.setter
    def z(self, value: builtins.float) -> None: ...
    def __new__(
        cls,
        x: builtins.float,
        y: typing.Optional[builtins.float] = None,
        z: typing.Optional[builtins.float] = None,
    ) -> DVec3: ...
    def to_tuple(self) -> tuple[builtins.float, builtins.float, builtins.float]:
        r"""
        Convert this vector to a 3 component tuple

        # Returns

        - `(float, float, float)` - XYZ tuple
        """
    def __add__(self, rhs: typing.Any) -> DVec3: ...
    def __radd__(self, lhs: typing.Any) -> DVec3: ...
    def __sub__(self, rhs: typing.Any) -> DVec3: ...
    def __rsub__(self, lhs: typing.Any) -> DVec3: ...
    def __mul__(self, rhs: typing.Any) -> DVec3: ...
    def __rmul__(self, lhs: typing.Any) -> DVec3: ...
    def __truediv__(self, rhs: typing.Any) -> DVec3: ...
    def __rtruediv__(self, lhs: typing.Any) -> DVec3: ...
    def __iadd__(self, rhs: typing.Any) -> None: ...
    def __isub__(self, rhs: typing.Any) -> None: ...
    def __imul__(self, rhs: typing.Any) -> None: ...
    def __itruediv__(self, rhs: typing.Any) -> None: ...
    def __neg__(self) -> DVec3: ...
    def normalize(self) -> DVec3: ...
    def length(self) -> builtins.float: ...
    def dot(self, rhs: typing.Any) -> builtins.float: ...
    def cross(self, rhs: typing.Any) -> DVec3: ...

@typing.final
class GeoOrientation:
    @staticmethod
    def from_identity() -> GeoOrientation:
        r"""
        Create an identity ecef orientation
        """
    @staticmethod
    def from_ecef(body2ecef: DQuat) -> GeoOrientation:
        r"""
        Construct an orientation from a body2ecef quaternion

        # Arguments

        - `body2ecef` (`&pyglam::DQuat`) - Quaternion rotating a body coordinate frame into the ecef frame
        """
    @staticmethod
    def from_geo_rotation_arc(from_: GeoPosition, to: GeoPosition) -> GeoOrientation:
        r"""
        Create a minimum rotation from one geo position to another

        # Arguments

        - `from_` (`&GeoPosition`) - Starting geo position
        - `to` (`&GeoPosition`) - Ending geo position
        """
    @staticmethod
    def from_axis_angle(ecef_axis: DVec3, angle: builtins.float) -> GeoOrientation:
        r"""
        Create an orientation from an ECEF Axis and angle in radians

        # Arguments

        - `ecef_axis` (`&DVec3`) - ECEF unit vector
        - `angle` (`f64`) - Angle in radians
        """
    @staticmethod
    def from_ecef_euler(ecef_321_rad: DVec3) -> GeoOrientation:
        r"""
        Construct an orientation from ecef euler angles in a 3-2-1 sequence

        # Arguments

        - `ecef_321` (`&pyglam`) - Euler angles in radians in ecef frame
        """
    @staticmethod
    def from_ned_euler(
        ned_321_rad: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoOrientation:
        r"""
        Construct a GeoOrientation from a local ned coordinate frame
        ned is the euler radians around north, east, down in a 3-2-1 sequence

        # Arguments

        - `ned_321` (`&pyglam`) - NED euler angles in radians
        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location
        """
    @staticmethod
    def from_enu_euler(
        enu_321: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoOrientation:
        r"""
        Construct a GeoOrientation from a local enu coordinate frame
        enu is the euler radians around east, north, up in a 3-2-1 sequence

        # Arguments

        - `enu_321` (`&pyglam`) - ENU euler angles in radians
        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location euler angles are in relation to
        """
    @staticmethod
    def from_enu_frame(
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoOrientation:
        r"""
        Construct a orientation aligned with the ENU frame at the given reference location

        # Arguments

        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference geo position
        """
    @staticmethod
    def from_ned_frame(
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoOrientation:
        r"""
        Construct a orientation aligned with the NED frame at the given reference location

        # Arguments

        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference geo position
        """
    def heading(
        self,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> builtins.float:
        r"""
        Gets the heading direction (clockwise off north) in degrees for the body's forward vector

        # Arguments

        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location to compute heading in relation to

        # Returns

        - `f64` - Heading angle in degrees
        """
    def as_enu(
        self,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> DQuat:
        r"""
        Express this bodies orientation in a local enu frame

        # Arguments

        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location

        # Returns

        - `pyglam::DQuat` - body 2 local enu rotation
        """
    def forward(self) -> DVec3:
        r"""
        Get the forward (positive x axis) for this orientation in the ecef frame
        """
    def left(self) -> DVec3:
        r"""
        Get the left (positive y axis) for this orientation in the ecef frame
        """
    def up(self) -> DVec3:
        r"""
        Get the up (positive z axis) for this orientation in the ecef frame
        """
    def right(self) -> DVec3:
        r"""
        Get the right (negative y axis) for this orientation in the ecef frame
        """
    def down(self) -> DVec3:
        r"""
        Get the down (negative z axis) for this orientation in the ecef frame
        """
    def back(self) -> DVec3:
        r"""
        Get the back (negative x axis) for this orientation in the ecef frame
        """
    def __mul__(
        self, rhs: typing.Union[GeoVector, GeoOrientation]
    ) -> typing.Union[GeoVector, GeoOrientation]:
        r"""
        Multiply this orientation with either a GeoPosition or a GeoOrientation

        Multiplying two orientations together results in a combined rotation
        Multiplying a position and an orientation results in the transformation of that vector in the orientation's frame

        # Arguments

        - `rhs` (`Either<GeoVector, GeoOrientation>`) - Either a GeoVector to transform or a GeoOrientation

        # Returns

        - `PyResult<Either<GeoVector, GeoOrientation>>` - Either a transformed GeoVector or a combined GeoOrientation
        """

@typing.final
class GeoPosition:
    r"""
    Represents a position on the earth
    """
    @property
    def ecef(self) -> DVec3: ...
    @ecef.setter
    def ecef(self, value: DVec3) -> None: ...
    @property
    def lla(self) -> tuple[builtins.float, builtins.float, builtins.float]: ...
    @staticmethod
    def from_ecef(ecef_m: DVec3) -> GeoPosition:
        r"""
        Construct a GeoPosition from an ECEF (Earth Centered, Earth Fixed) vec3 in meters

        # Arguments

        - `ecef` (`DVec3`) - ECEF location in meters
        """
    @staticmethod
    def from_lla(
        lla_ddm: tuple[builtins.float, builtins.float, builtins.float],
    ) -> GeoPosition:
        r"""
        Construct a GeoPosition from a WGS84 Latitude, Longitude, Altitude in deg,deg,meters

        # Arguments

        - `lla` (`(float, float, float)`) - WGS84 lat, lon, alt in [[degrees, degrees, meters]]
        """
    @staticmethod
    def from_enu(
        enu_m: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoPosition:
        r"""
        Construct a GeoPosition from a local east, north, up vector in meters relative to a reference location

        # Arguments

        - `enu_m` (`&DVec3`) - East, North, Up vector in meters
        - `reference` (`EitherGeoPosOrLLATup`) - Reference location
        """
    @staticmethod
    def from_ned(
        ned_m: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoPosition:
        r"""
        Construct a GeoPosition from a local north, east, down vector in meters relative to a reference location

        # Arguments

        - `ned_m` (`&DVec3`) - North, East, Down vector in meters
        - `reference` (`EitherGeoPosOrLLATup`) - Reference location
        """
    @staticmethod
    def from_aer(
        aer_ddm: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoPosition:
        r"""
        Construct a GeoPosition from a local az, el, range vector in deg,deg,meters relative to a reference location

        # Arguments

        - `aer_ddm` (`&DVec3`) - Azimuth, Elevation, Range in deg,deg,meters
        - `reference` (`EitherGeoPosOrLLATup`) - Reference location
        """
    def alt(self) -> builtins.float: ...
    def set_alt(self, alt_m: builtins.float) -> None:
        r"""
        Sets the altitude of this position while preserving the lat/lon

        # Arguments

        - `alt_m` (`f64`) - New MSL altitude in meters
        """
    def bearing_to(self, to_point: GeoPosition) -> builtins.float: ...
    def enu_to(self, to_point: GeoPosition) -> DVec3: ...
    def aer_to(self, to_point: GeoPosition) -> DVec3: ...
    def ned_to(self, to_point: GeoPosition) -> DVec3: ...
    def bearing_from(self, from_point: GeoPosition) -> builtins.float: ...
    def enu_from(self, from_point: GeoPosition) -> DVec3: ...
    def aer_from(self, from_point: GeoPosition) -> DVec3: ...
    def ned_from(self, from_point: GeoPosition) -> DVec3: ...
    def distance(self, other: GeoPosition) -> builtins.float: ...
    def lat_lon_dms(self) -> builtins.str: ...
    def rotate_lat_lon(self, ecef_rot: DQuat) -> None:
        r"""
        Rotate the geo position by an ecef rotation, but preserve the starting altitude
        """
    def __repr__(self) -> builtins.str: ...
    def __add__(self, rhs: typing.Union[GeoVector, DVec3]) -> GeoPosition: ...
    def __radd__(self, rhs: typing.Union[GeoVector, DVec3]) -> GeoPosition: ...
    def __sub__(
        self, rhs: typing.Union[GeoVector, GeoPosition]
    ) -> typing.Union[GeoVector, GeoPosition]: ...
    def __rsub__(self, lhs: GeoPosition) -> GeoVector: ...

@typing.final
class GeoVector:
    r"""
    Represents a vector relative to a reference point
    """
    @property
    def ecef_uvw(self) -> DVec3:
        r"""
        Gets this vector in the ECEF frame in meters
        """
    @ecef_uvw.setter
    def ecef_uvw(self, value: DVec3) -> None: ...
    @staticmethod
    def from_ecef(
        ecef_uvw: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVector: ...
    @staticmethod
    def from_enu(
        enu: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVector: ...
    @staticmethod
    def from_ned(
        ned: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVector: ...
    @staticmethod
    def from_aer(
        aer: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVector: ...
    def length(self) -> builtins.float:
        r"""
        Compute the length of this vector in meters

        # Returns

        * `length` - Length of this vector in [[meters]]
        """
    def ecef(self) -> DVec3:
        r"""
        Get the absolute ecef position of this vector

        # Returns

        - `pyglam::DVec3` - Absolute ecef position in meters
        """
    def enu(self) -> DVec3: ...
    def ned(self) -> DVec3: ...
    def aer(self) -> DVec3: ...
    def north(self) -> builtins.float: ...
    def south(self) -> builtins.float: ...
    def east(self) -> builtins.float: ...
    def west(self) -> builtins.float: ...
    def up(self) -> builtins.float: ...
    def down(self) -> builtins.float: ...
    def azimuth(self) -> builtins.float:
        r"""
        Compute the clockwise angle off true north for this vector relative to its reference
        Angle is always between [0., 360.]

        # Returns

        * `azimuth` - Clockwise angle off true north in [[degrees]]
        """

@typing.final
class GeoVelocity:
    r"""
    Represents a 3D velocity vector in geo space
    Velocity is stored as a direction and speed so that a 0 velocity still has a direction associated with it
    """
    @property
    def ecef_uvw(self) -> DVec3:
        r"""
        Get this velocity in ecef frame

        # Returns

        - `DVec3` - ECEF velocity in m/s
        """
    @property
    def speed(self) -> builtins.float:
        r"""
        Gets the speed of this velocity in m/s
        """
    @speed.setter
    def speed(self, value: builtins.float) -> None: ...
    @property
    def direction(self) -> DVec3:
        r"""
        Get this velocity's direction in the ecef frame
        """
    @direction.setter
    def direction(self, value: DVec3) -> None: ...
    @staticmethod
    def from_dir_speed(ecef_dir: DVec3, speed_mps: builtins.float) -> GeoVelocity:
        r"""
        Construct a velocity from an ecef unit direction and speed

        # Arguments

        - `ecef_dir` (`&DVec3`) - Unit vector in ecef frame
        - `speed_mps` (`f64`) - speed in meters per second
        """
    @staticmethod
    def from_ecef_uvw(ecef_uvw_mps: DVec3) -> GeoVelocity:
        r"""
        Construct a velocity from an ecef vector in meters/second

        # Arguments

        - `ecef` (`&DVec3`) - Velocity vector in ecef frame in meters/second
        """
    @staticmethod
    def from_enu(
        enu_mps: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVelocity:
        r"""
        Construct a velocity from a local enu velocity vector in meters/second

        # Arguments

        - `enu_mps` (`&DVec3`) - Local enu velocity in meters/second
        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location
        """
    @staticmethod
    def from_ned(
        ned_mps: DVec3,
        reference: typing.Union[
            tuple[builtins.float, builtins.float, builtins.float], GeoPosition
        ],
    ) -> GeoVelocity:
        r"""
        Construct a velocity from a local ned velocity vector in meters/second

        # Arguments

        - `ned_mps` (`&DVec3`) - Local ned velocity in meters/second
        - `reference` (`tuple[float, float, float] | GeoPosition`) - Reference location
        """
    def enu(self, reference: GeoPosition) -> DVec3:
        r"""
        Get this velocity in a local enu frame in m/s

        # Arguments

        - `reference` (`GeoPosition`) - enu reference frame
        """
    def ned(self, reference: GeoPosition) -> DVec3:
        r"""
        Get this velocity in a local ned frame in m/s

        # Arguments

        - `reference` (`GeoPosition`) - ned reference frame
        """
    def mach(self, reference: GeoPosition) -> builtins.float:
        r"""
        Computes the mach number for this velocity at a given geo position

        # Arguments

        - `reference` (`&GeoPosition`) - Position to compute mach

        # Returns

        - `f64` - Mach number as an index
        """
    def __mul__(
        self, rhs: typing.Union[GeoVelocity, builtins.float]
    ) -> typing.Union[GeoVelocity, GeoVector]:
        r"""
        Multiply this GeoVelocity with either another GeoVelocity or time
        Multiplying by a float will produce a GeoVector equal to v * dt

        # Arguments

        - `rhs` (`Either<GeoVelocity, f64>`) - Velocity or time to multiply

        # Returns

        - `PyResult<Either<GeoVelocity, GeoVector>>` - Either a component-wise velocity multiply or a new GeoVector in meters
        """
    def __rmul__(
        self, rhs: typing.Union[GeoVelocity, builtins.float]
    ) -> typing.Union[GeoVelocity, GeoVector]: ...
    def __add__(self, rhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise addition of velocity
        """
    def __sub__(self, rhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise subtraction of velocity
        """
    def __div__(self, rhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise division of velocity
        """
    def __radd__(self, lhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise addition of velocity
        """
    def __rsub__(self, lhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise subtraction of velocity
        """
    def __rdiv__(self, lhs: GeoVelocity) -> GeoVelocity:
        r"""
        Component-wise division of velocity
        """

@typing.final
class Quat:
    r"""
    4 Component Quaternion wxyz
    """
    def __new__(
        cls, x: builtins.float, y: builtins.float, z: builtins.float, w: builtins.float
    ) -> Quat:
        r"""
        Create a new quaternion from components.
        Usually you want `from_axis_angle` or `from_rotation_arc` instead of this

        # Arguments

        - `x` (`float`) - x component
        - `y` (`float`) - y component
        - `z` (`float`) - z component
        - `w` (`float`) - scalar component

        # Returns

        - `PyResult<Self>` - Describe the return value.
        """
    @staticmethod
    def from_axis_angle(axis: Vec3, angle: builtins.float) -> Quat:
        r"""
        Create a new quaternion from an axis and angle

        # Arguments

        - `axis` (`vec3`) - Axis, should be normalized
        - `angle` (`float`) - Angle in radians

        # Returns

        - `PyResult<Self>` - Quaternion describing this axis/angle rotation
        """
    @staticmethod
    def from_rotation_arc(from_: Vec3, to: Vec3) -> Quat:
        r"""
        Gets the minimal rotation for transforming `from` to `to`.  The rotation is in the
        plane spanned by the two vectors.  Will rotate at most 180 degrees.

        `from_rotation_arc(from, to) * from ≈ to`.

        For near-singular cases (from≈to and from≈-to) the current implementation
        is only accurate to about 0.001 (for `f32`).

        # Arguments

        - `from_` (`vec3`) - starting vector. Must be a unit vector
        - `to` (`vec3`) - ending vector. Must be a unit vector

        # Returns

        - `PyResult<Self>` - Returns a quaternion that would rotate vector from onto to
        """
    def to_tuple(
        self,
    ) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
        r"""
        Convert this quat to a 4 component tuple

        # Returns

        - `(float, float, float, float)` - XYZW tuple
        """
    def __mul__(self, rhs: typing.Any) -> typing.Union[Quat, Vec3]:
        r"""
        Multiply this quaternion with either another quaternion or a vector

        A quaternion multiplication means combining two rotations into a single rotation
        A vector multiplication yields a rotated vec3

        # Arguments

        - `rhs` (`Bound<'_, PyAny>`) - Quat or Vec to multiply

        # Returns

        - `PyResult<Either<, >>` - Either a new rotation or a rotated vector
        """
    def __rmul__(self, lhs: typing.Any) -> typing.Union[Quat, Vec3]:
        r"""
        Multiply this quaternion with either another quaternion or a vec3

        Order doesn't matter for multiplying a vector and a quat, but order matters for multiplying two quats

        # Arguments

        - `lhs` (`Bound<'_, PyAny>`) - left hand side multiplicand

        # Returns

        - `PyResult<Either<, >>` - Either a quat equivalent to the combined rotation or a rotated vector
        """
    def normalize(self) -> Quat:
        r"""
        Normalize this quaternion into a unit quat
        """
    def conjugate(self) -> Quat:
        r"""
        Compute the conjugate of this quat.
        If this is a unit quat, the conjugate is equal to the inverse of the rotation
        """

@typing.final
class Vec3:
    r"""
    3 Component vector xyz
    """
    @property
    def x(self) -> builtins.float: ...
    @x.setter
    def x(self, value: builtins.float) -> None: ...
    @property
    def y(self) -> builtins.float: ...
    @y.setter
    def y(self, value: builtins.float) -> None: ...
    @property
    def z(self) -> builtins.float: ...
    @z.setter
    def z(self, value: builtins.float) -> None: ...
    def __new__(
        cls,
        x: builtins.float,
        y: typing.Optional[builtins.float] = None,
        z: typing.Optional[builtins.float] = None,
    ) -> Vec3: ...
    def to_tuple(self) -> tuple[builtins.float, builtins.float, builtins.float]:
        r"""
        Convert this vector to a 3 component tuple

        # Returns

        - `(float, float, float)` - XYZ tuple
        """
    def __add__(self, rhs: typing.Any) -> Vec3: ...
    def __radd__(self, lhs: typing.Any) -> Vec3: ...
    def __sub__(self, rhs: typing.Any) -> Vec3: ...
    def __rsub__(self, lhs: typing.Any) -> Vec3: ...
    def __mul__(self, rhs: typing.Any) -> Vec3: ...
    def __rmul__(self, lhs: typing.Any) -> Vec3: ...
    def __truediv__(self, rhs: typing.Any) -> Vec3: ...
    def __rtruediv__(self, lhs: typing.Any) -> Vec3: ...
    def __iadd__(self, rhs: typing.Any) -> None: ...
    def __isub__(self, rhs: typing.Any) -> None: ...
    def __imul__(self, rhs: typing.Any) -> None: ...
    def __itruediv__(self, rhs: typing.Any) -> None: ...
    def __neg__(self) -> Vec3: ...
    def normalize(self) -> Vec3: ...
    def length(self) -> builtins.float: ...
    def dot(self, rhs: typing.Any) -> builtins.float: ...
    def cross(self, rhs: typing.Any) -> Vec3: ...

def aer2ecef(
    a_d: builtins.float,
    e_d: builtins.float,
    r_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER from a given lat/lon to a new ECEF location

    # Arguments

    * `a_d` - Azimuth in degrees [float]
    * `e_d` - Elevation in degrees [float]
    * `r_m` - Range in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef` - Absolute ECEF position in meters
    """

def aer2ecef_uvw(
    a_d: builtins.float,
    e_d: builtins.float,
    r_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts a vector direction and distance given in AER to ECEF uvw

    # Arguments

    * `a_d` - Azimuth in degrees [float]
    * `e_d` - Elevation in degrees [float]
    * `r_m` - Range in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef_uvw` - Vector represented in ECEF frame. Not an absolute position [[meters]].
    """

def aer2enu(
    a_d: builtins.float, e_d: builtins.float, r_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER vector direction and magnitude to ENU.

    # Arguments

    * `a_d` - Azimuth in degrees [float]
    * `e_d` - Elevation in degrees [float]
    * `r_m` - Range in meters [float]

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def aer2ned(
    a_d: builtins.float, e_d: builtins.float, r_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts AER vector direction and magnitude to NED.

    # Arguments

    * `a_d` - Azimuth in degrees [float]
    * `e_d` - Elevation in degrees [float]
    * `r_m` - Range in meters [float]

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def angle_between(
    ax: builtins.float,
    ay: builtins.float,
    az: builtins.float,
    bx: builtins.float,
    by: builtins.float,
    bz: builtins.float,
) -> builtins.float:
    r"""
    Computes the angle between two vectors in radians. Dot product is clamped to [-1, 1] so this always outputs a number

    # Arguments

    * `ax` - a vector x [float]
    * `ay` - a vector y [float]
    * `az` - a vector z [float]
    * `bx` - b vector x [float]
    * `by` - b vector y [float]
    * `bz` - b vector z [float]

    # Returns

    * `angle` - angle between the two vectors in radians
    """

def dd2dms(dd: builtins.float, is_lat: builtins.bool) -> builtins.str:
    r"""
    Converts decimal degrees (DD) to degrees-minutes-seconds (DMS).

    # Arguments

    * `dd` - Decimal degrees [degrees].
    * `is_lat` - Flag to denote if this decimal value describes a latitude [bool]

    # Returns

    * `dms` - Format "{Degrees}:{Minutes}:{Seconds}.{DecSeconds}{Direction}" where Direction is one of N, E, S, or W.

    # Examples
    ```
    dms = map3d.dd2dms(25.37909389, true) #> "25:22:44.738N"
    ```
    """

def dms2dd(dms: builtins.str) -> builtins.float:
    r"""
    Converts degrees-minutes-seconds (DMS) to decimal degrees (DD).

    # Arguments

    * `dms` - Format "{Degrees}:{Minutes}:{Seconds}.{DecSeconds}{Direction}" where Direction is one of N, E, S, or W.

    # Returns

    * `dd` - Decimal degrees [degrees].

    # Examples
    ```
    dd = map3d.dms2dd("25:22:44.738N")  #> 25.37909389
    ```
    """

def ecef2aer(
    x_m: builtins.float,
    y_m: builtins.float,
    z_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an absolute ECEF to AER (az el range).

    # Arguments

    * `x_m` - ECEF x in meters [float]
    * `y_m` - ECEF y in meters [float]
    * `z_m` - ECEF z in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def ecef2enu(
    x_m: builtins.float,
    y_m: builtins.float,
    z_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an ECEF position to ENU.

    # Arguments

    * `x_m` - ECEF x in meters [float]
    * `y_m` - ECEF y in meters [float]
    * `z_m` - ECEF z in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def ecef2enu_dcm(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ECEF to ENU transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `dcm` - ECEF to ENU direction cosine matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]]
    """

def ecef2enu_quat(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ECEF to ENU transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `quat` - Normalized ECEF to ENU quaternion.
    """

def ecef2lla(
    x_m: builtins.float, y_m: builtins.float, z_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF to WGS84 LLA

    # Arguments

    * `x_m` - ECEF x in meters [float]
    * `y_m` - ECEF y in meters [float]
    * `z_m` - ECEF z in meters [float]

    # Returns

    * `lla` - Vector represented in WGS84 LLA [degrees-degrees-meters].
    """

def ecef2ned(
    x_m: builtins.float,
    y_m: builtins.float,
    z_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an absolute ECEF location to NED.

    # Arguments

    * `x_m` - ECEF x in meters [float]
    * `y_m` - ECEF y in meters [float]
    * `z_m` - ECEF z in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def ecef2ned_dcm(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ECEF to NED transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `dcm` - ECEF to NED direction cosine matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]]
    """

def ecef2ned_quat(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ECEF to NED transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `quat` - Normalized ECEF to NED quaternion (w, x, y, z).
    """

def ecef_quat2heading(
    w: builtins.float,
    x: builtins.float,
    y: builtins.float,
    z: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> builtins.float:
    r"""
    Computes the clockwise angle from North of a local body-frame's x-axis

    # Arguments

    * `w` - Scalar part of quaternion [float]
    * `x` - x part of quaternion [float]
    * `y` - y part of quaternion [float]
    * `z` - z part of quaternion [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    *  `heading` - Clockwise angle off true north [[degrees]] of the body's x axis
    """

def ecef_uvw2aer(
    u_m: builtins.float,
    v_m: builtins.float,
    w_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF uvw to AER (az el range).

    # Arguments

    * `u_m` - ECEF u in meters [float]
    * `v_m` - ECEF v in meters [float]
    * `w_m` - ECEF w in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def ecef_uvw2enu(
    u_m: builtins.float,
    v_m: builtins.float,
    w_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an ECEF uvw vector to ENU.

    # Arguments

    * `u_m` - ECEF u in meters [float]
    * `v_m` - ECEF v in meters [float]
    * `w_m` - ECEF w in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def ecef_uvw2ned(
    u_m: builtins.float,
    v_m: builtins.float,
    w_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ECEF UVW Vector to NED.

    # Arguments

    * `u_m` - ECEF u in meters [float]
    * `v_m` - ECEF v in meters [float]
    * `w_m` - ECEF w in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def enu2aer(
    e_m: builtins.float, n_m: builtins.float, u_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to AER.

    # Arguments

    * `e_m` - East in meters [float]
    * `n_m` - North in meters [float]
    * `u_m` - Up in meters [float]

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def enu2ecef(
    e_m: builtins.float,
    n_m: builtins.float,
    u_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to an ECEF position

    # Arguments

    * `e_m` - East in meters [float]
    * `n_m` - North in meters [float]
    * `u_m` - Up in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef` - Absolute ECEF position in meters
    """

def enu2ecef_dcm(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an ENU to ECEF transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `dcm` - ENU to ECEF direction cosine matrix [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]]
    """

def enu2ecef_quat(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an ENU to ECEF transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `quat` - Normalized ENU to ECEF quaternion (w, x, y, z).
    """

def enu2ecef_uvw(
    e_m: builtins.float,
    n_m: builtins.float,
    u_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to ECEF uvw vector

    # Arguments

    * `e_m` - East in meters [float]
    * `n_m` - North in meters [float]
    * `u_m` - Up in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef_uvw` - Vector represented in ECEF frame. Not an absolute position [[meters]].
    """

def enu2heading(
    e_m: builtins.float, n_m: builtins.float, u_m: builtins.float
) -> builtins.float:
    r"""
    Calculates heading angle from ENU.

    # Arguments

    * `e_m` - East in meters [float]
    * `n_m` - North in meters [float]
    * `u_m` - Up in meters [float]

    # Returns

    * `heading_deg` - Heading angle relative to true north [degrees].
    """

def enu2lla(
    e_m: builtins.float,
    n_m: builtins.float,
    u_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts ENU to an absolute LLA position

    # Arguments

    * `e_m` - East in meters [float]
    * `n_m` - North in meters [float]
    * `u_m` - Up in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `lla` - Absolute LLA position [deg-deg-m]
    """

def ll2dms(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[builtins.str, builtins.str]:
    r"""
    Convenience function to convert lat/lon to a tuple of (lat dms, lon dms)

    # Arguments

    * `lat` - Latitude in decimal degrees
    * `lon` - Longitude in decimal degrees

    # Returns

    * `(lat dms, lon dms)` - Tuple of lat/lon as degrees:minutes:seconds [Tuple[String, String]]
    ```
    """

def lla2ecef(
    lat_d: builtins.float, lon_d: builtins.float, alt_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts WGS84 LLA to ECEF.

    # Arguments

    * `lat_d` - WGS84 Lat in degrees [float]
    * `lon_d` - WGS84 Lon in degrees [float]
    * `alt_m` - WGS84 MSL alt in meters [float]

    # Returns

    * `ecef` - Vector represented in ECEF coordinates [meters].
    """

def lla2enu(
    lat_d: builtins.float,
    lon_d: builtins.float,
    alt_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an absolute LLA position to an ENU vector relative to a lla reference

    # Arguments

    * `lat_d` - WGS84 Lat in degrees [float]
    * `lon_d` - WGS84 Lon in degrees [float]
    * `alt_m` - WGS84 MSL alt in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `enu` - Vector represented in ENU coordinates [meters].
    """

def lla2ned(
    lat_d: builtins.float,
    lon_d: builtins.float,
    alt_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts an absolute LLA location to a NED vector relative to a lla reference point

    # Arguments

    * `lat_d` - WGS84 Lat in degrees [float]
    * `lon_d` - WGS84 Lon in degrees [float]
    * `alt_m` - WGS84 MSL alt in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ned` - Vector represented in NED coordinates [meters].
    """

def ned2aer(
    n_m: builtins.float, e_m: builtins.float, d_m: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts NED to AER.

    # Arguments

    * `n_m` - North in meters [float]
    * `e_m` - East in meters [float]
    * `d_m` - Down in meters [float]

    # Returns

    * `aer` - Vector represented in AER coordinates [degrees-degrees-meters].
    """

def ned2ecef(
    n_m: builtins.float,
    e_m: builtins.float,
    d_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts NED to an absolute ECEF location

    # Arguments

    * `n_m` - North in meters [float]
    * `e_m` - East in meters [float]
    * `d_m` - Down in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef` - Absolute ECEF position in meters
    """

def ned2ecef_dcm(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
    builtins.float,
]:
    r"""
    Calculates the direction cosine matrix that yields an NED to ECEF transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `dcm` - NED to ECEF direction cosine matrix  [[xx, xy, xz], [yx, yy, yz], [zx, zy, zz]]
    """

def ned2ecef_quat(
    lat_d: builtins.float, lon_d: builtins.float
) -> tuple[builtins.float, builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates the quaternion that yields an NED to ECEF transformation at this LLA.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].

    # Returns

    * `quat` - Normalized NED to ECEF quaternion (w, x, y, z).
    """

def ned2ecef_uvw(
    n_m: builtins.float,
    e_m: builtins.float,
    d_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts NED to ECEF uvw

    # Arguments

    * `n_m` - North in meters [float]
    * `e_m` - East in meters [float]
    * `d_m` - Down in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `ecef_uvw` - Vector represented in ECEF frame. Not an absolute position [[meters]].
    """

def ned2lla(
    n_m: builtins.float,
    e_m: builtins.float,
    d_m: builtins.float,
    lat_ref_d: builtins.float,
    lon_ref_d: builtins.float,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Converts a NED vector to an absolute lat lon alt

    # Arguments

    * `n_m` - North in meters [float]
    * `e_m` - East in meters [float]
    * `d_m` - Down in meters [float]
    * `lat_ref_d` - Reference WGS84 Lat in degrees [float]
    * `lon_ref_d` - Reference WGS84 Lon in degrees [float]

    # Returns

    * `lla` - Absolute lat lon alt [deg-deg-m]
    """

def rand_ecef() -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Generates a uniform random ECEF point on the surface of a spherical Earth.

    # Returns

    * `ecef` - Random ECEF location [meters].
    """

def rand_lla() -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Generates a uniform random LLA point. Altitude is generated in the domain [0.0, 10000.0].

    # Returns

    * `lla` - Random LLA location [degrees-degrees-meters].
    """

def rand_orientation() -> tuple[
    builtins.float, builtins.float, builtins.float, builtins.float
]:
    r"""
    Generates a random normalized quaternion.

    # Returns

    * `quat` - Random normalized quaternion (w, x, y, z).
    """

def vincenty_direct(
    lat_d: builtins.float,
    lon_d: builtins.float,
    range_m: builtins.float,
    bearing_d: builtins.float,
    atol: builtins.float = ...,
    max_iters: builtins.int = ...,
) -> tuple[builtins.float, builtins.float]:
    r"""
    Calculates the LLA location that is a fixed range and bearing from a reference LLA. This function uses an iterative
    solution to determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_d` - Latitude reference in degrees [float].
    * `lon_d` - Longitude reference in degrees [float].
    * `range_m` - Range (i.e., distance) from point A to point B [meters].
    * `bearing_d` - Bearing (i.e., azimuth) from point A to point B relative to true north [degrees].
    * `abs_tol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(lat_deg, lon_deg)` where:
    * `lat_deg` - Latitude location [degrees].
    * `lon_deg` - Longitude location [degrees].
    """

def vincenty_inverse(
    lat_a_deg: builtins.float,
    lon_a_deg: builtins.float,
    lat_b_deg: builtins.float,
    lon_b_deg: builtins.float,
    atol: builtins.float = ...,
    max_iters: builtins.int = ...,
) -> tuple[builtins.float, builtins.float, builtins.float]:
    r"""
    Calculates range and bearings between two latitude-longitude points. This function uses an iterative solution to
    determine outputs using the WGS84 ellipsoidal Earth model.

    See reference:
    https://en.wikipedia.org/wiki/Vincenty%27s_formulae.

    # Arguments

    * `lat_a_deg` - Latitude point A [degrees].
    * `lon_a_deg` - Longitude point A [degrees].
    * `lat_b_deg` - Latitude point A [degrees].
    * `lon_b_deg` - Longitude point A [degrees].
    * `atol` - Absolute tolerance used for convergence.
    * `max_iters` - Maximum possible number of iterations before early termination.

    # Returns

    A tuple `(range_m, bearing_ab_deg, bearing_ba_deg)` where:
    * `range_m` - Range (i.e., distance) from point A to point B [meters].
    * `bearing_ab_deg` - Bearing (i.e., azimuth) from point A to point B relative to true north [degrees].
    * `bearing_ba_deg` - Bearing (i.e., azimuth) from point B to point A relative to true north [degrees].
    """
